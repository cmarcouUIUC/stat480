---
title: "Homework 3 Assignment"
author: "Carrie Mecca, Charlie Marcou, Jessie Bustin and Jasmine Zhang"
fontsize: 10 pt
output: 
    pdf_document:
        fig_width: 6
        fig_height: 4
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      #include = TRUE, 
                      fig.width = 6, fig.height = 4,
                      results='hide',
                      warning = FALSE,
                      message = FALSE,
                      cache = TRUE,
                      digits = 3,
                      width = 48) 
```

Each question is 10 points. Bonus is up to 5 points.

# Starter code

```{r}
## microfinance network 
## data from BANERJEE, CHANDRASEKHAR, DUFLO, JACKSON 2012

## data on 8622 households
hh <- read.csv("microfi_households.csv", row.names="hh")
hh$village <- factor(hh$village)

## We'll kick off with a bunch of network stuff.
## This will be covered in more detail in lecture 6.
## get igraph off of CRAN if you don't have it
## install.packages("igraph")
## this is a tool for network analysis
## (see http://igraph.sourceforge.net/)
library(igraph)
edges <- read.table("microfi_edges.txt", colClasses="character")
## edges holds connections between the household ids
hhnet <- graph.edgelist(as.matrix(edges))
hhnet <- as.undirected(hhnet) # two-way connections.

## igraph is all about plotting.  
V(hhnet) ## our 8000+ household vertices
## Each vertex (node) has some attributes, and we can add more.
V(hhnet)$village <- as.character(hh[V(hhnet),'village'])
## we'll color them by village membership
vilcol <- rainbow(nlevels(hh$village))
names(vilcol) <- levels(hh$village)
V(hhnet)$color = vilcol[V(hhnet)$village]
## drop HH labels from plot
V(hhnet)$label=NA

# graph plots try to force distances proportional to connectivity
# imagine nodes connected by elastic bands that you are pulling apart
# The graphs can take a very long time, but I've found
# edge.curved=FALSE speeds things up a lot.  Not sure why.

## we'll use induced.subgraph and plot a couple villages 
village1 <- induced.subgraph(hhnet, v=which(V(hhnet)$village=="1"))
village33 <- induced.subgraph(hhnet, v=which(V(hhnet)$village=="33"))

# vertex.size=3 is small.  default is 15
plot(village1, vertex.size=3, edge.curved=FALSE)
plot(village33, vertex.size=3, edge.curved=FALSE)

######  now, on to your homework stuff

library(gamlr)

## match id's; I call these 'zebras' because they are like crosswalks
zebra <- match(rownames(hh), V(hhnet)$name)

## calculate the `degree' of each hh: 
##  number of commerce/friend/family connections
degree <- degree(hhnet)[zebra]
names(degree) <- rownames(hh)
degree[is.na(degree)] <- 0 # unconnected houses, not in our graph

## if you run a full glm, it takes forever and is an overfit mess
# > summary(full <- glm(loan ~ degree + .^2, data=hh, family="binomial"))
# Warning messages:
# 1: glm.fit: algorithm did not converge 
# 2: glm.fit: fitted probabilities numerically 0 or 1 occurred 

```

# Question 1 

I'd transform degree to create our treatment variable $d$.
What would you do and why?

We can see that degree is heavily left-skewed. A transformation to correct this might be a log or square root transformation.

```{r}
hist(degree)
hist(log(degree+1))
hist(sqrt(degree))
##idk which looks better to you?
#i think the log looks better - carrie
d=log(degree+1)
```


# Question 2

Build a model to predict $d$ from $x$, our controls. Comment on how tight the fit is, and what that implies for estimation of a treatment effect.

```{r}
library(gamlr)

#is this what we're meant to do? factor all the categorical vars?
controls = hh[,c(4:5)]
v <- factor(hh$village)
v <- factor(v, levels=c(NA,levels(v)), exclude=NULL)

rl <- factor(hh$religion)
rl <- factor(rl, levels=c(NA,levels(rl)), exclude=NULL)

rf <- factor(hh$roof)
rf <- factor(rf, levels=c(NA,levels(rf)), exclude=NULL)

e <- factor(hh$electricity)
e <- factor(e, levels=c(NA,levels(e)), exclude=NULL)

o <- factor(hh$ownership)
o <- factor(o, levels=c(NA,levels(o)), exclude=NULL)

l <- factor(hh$leader)
l <- factor(l, levels=c(NA,levels(l)), exclude=NULL)

x = sparse.model.matrix(~ v + rl + rf + e + o + l, data=controls)[,-1]
dim(x)

# do LASSO of treatment on confounders
treat <- gamlr(x,d,lambda.min.ratio=1e-4)
summary(treat)
```

# Question 3

Use predictions from Q2 in an estimator for effect of $d$ on loan.

```{r}
##Get predictions
y <- hh$loan
dhat <- predict(treat, x, type="response") 
causal <- gamlr(cbind(d,dhat,x),y,free=2,lmr=1e-4)
coef(causal)["d",]
cor(drop(dhat),d)^2 #R^2
```


# Question 4

Compare the results from Q3 to those from a straight (naive) lasso
for loan on $d$ and $x$. Explain why they are similar or different.

```{r}
naive <- gamlr(cbind(d,x),y)
coef(naive)["d",]
```


# Question 5

Bootstrap your estimator from Q3 and describe the uncertainty.

```{r}
## BOOTSTRAP 
n <- nrow(x)

## Bootstrapping our lasso causal estimator is easy
gamb <- c() # empty gamma

for(b in 1:20){
	## create a matrix of resampled indices
	ib <- sample(1:n, n, replace=TRUE)

	## create the resampled data
	xb <- x[ib,]
	db <- d[ib]
	yb <- y[ib]

	## run the treatment regression
	treatb <- gamlr(xb,db,lambda.min.ratio=1e-3)
	dhatb <- predict(treatb, xb, type="response")
	fitb <- gamlr(cbind(db,dhatb,xb),yb,free=2)
	gamb <- c(gamb,coef(fitb)["db",])
}

summary(gamb) 
```

# Bonus 

Can you think of how you'd design an experiment to estimate the treatment effect of network degree?


